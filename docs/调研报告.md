# 调研报告

## 目录

[TOC]



## 项目成员

雷雨轩

裴启智

刘逸菲

孙一鸣

曲阳

***

## 项目简介

​		该项目通过高效、安全的Rust语言对17级项目“基于互联网网页的小型分布式文件系统”进行改写，并用极具计算效率和兼容性的WebAssembly来代替JavaScript实现网页前端逻辑以及实现分布式文件系统程序的包装，最终通过Node.js(V8引擎)实现跨平台的，可提供移动式文件访问的分布式文件系统，并在性能、兼容性、创新性上取得突破。

***

## 项目背景

***

### 基于互联网网页的小型分布式文件系统

​		计算机通过文件系统管理、存储数据，而信息爆炸时代中人们可以获取的数据成指数倍的增长，单纯通过增加硬盘个数来扩展计算机文件系统的存储容量的方式，在容量大小、容量增长速度、数据备份、数据安全等方面的表现都差强人意。分布式文件系统可以有效解决数据的存储和管理难题：将固定于某个地点的某个文件系统，扩展到任意多个地点/多个文件系统，众多的节点组成一个文件系统网络。每个节点可以分布在不同的地点，通过网络进行节点间的通信和数据传输。人们在使用分布式文件系统时，无需关心数据是存储在哪个节点上、或者是从哪个节点从获取的，只需要像使用本地文件系统一样管理和存储文件系统中的数据。

![img](https://bkimg.cdn.bcebos.com/pic/34fae6cd7b899e51d6ca036a42a7d933c8950d03?x-bce-process=image/watermark,g_7,image_d2F0ZXIvYmFpa2U4MA==,xp_5,yp_5)

#### DFS调研

#### 客户端和服务器端的java实现

#### web服务程序的实现

### Webassembly

#### 定义

* 定义一个可移植，具有大小与载入高效率的二进位格式，作为编译标的。这个编译标的必须可以被编译至常见的平台，包含移动端与物联网，并且可以善用硬体资源、有原生执行码的执行速度
* 一种可以使用非 JavaScript 编程语言编写代码并且能在浏览器上运行的技术方案
* 并不是一门编程语言，而是一份字节码标准，需要用高级编程语言编译出字节码放到 WebAssembly 虚拟机中才能运行， 浏览器厂商需要做的就是根据 WebAssembly 规范实现虚拟机

#### 特点

* 高效：有一套完整的语义，实际上 wasm 是体积小且加载快的二进制格式， 其目标就是充分发挥硬件能力以达到原生执行效率
* 安全：WebAssembly 运行在一个沙箱化的执行环境中，甚至可以在现有的 JavaScript 虚拟机中实现。在web环境中，WebAssembly将会严格遵守同源策略以及浏览器安全策略
* 开放：WebAssembly 设计了一个非常规整的文本格式用来、调试、测试、实验、优化、学习、教学或者编写程序。可以以这种文本格式在web页面上查看wasm模块的源码。
* 标准：WebAssembly 在 web 中被设计成无版本、特性可测试、向后兼容的。WebAssembly 可以被 JavaScript 调用，进入 JavaScript 上下文，也可以像 Web API 一样调用浏览器的功能。当然，WebAssembly 不仅可以运行在浏览器上，也可以运行在非web环境下。

### Rust

#### 特点

* Rust的设计目标之一，是要使设计大型的互联网客户端和服务器的任务变得更容易。因此更加强调安全性、存储器配置、以及并发处理等方面的特性。四个关键词，系统编程、安全、并发、高效。

* 安全性

  Rust 有植入类型系统的生命周期体系。

  引入了所有权，不允许空指针、悬垂指针、double free、数据竞争等，在编译阶段保证内存安全和线程安全(零开销安全性特点)。

  * 数据竞争问题

    对于同一作用域内的同一变量，该变量的引用必须满足下述规则之一：引用均为不可变引用；只有一个可变引用；有多个可变引用或一个可变引用和多个不可变引用，但每个引用的作用域不相交。

    Rust通过这样的限制，使可能出现数据竞争的代码不能通过编译。

  * 悬垂指针

    https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html  Dangling references

  可以使用unsafe标签使代码通过编译，再集中调试该代码块。

* 性能

  性能和标准的 C++ 性能不相上下。

  没有运行时(Run time)和垃圾回收(Garbage Collector)，通过生命周期和所有权特性实现内存自动回收，保证了实时性，低开销，适于在嵌入式设备资源匮乏环境下运行。

* 开发环境

  生态逐渐完善。相关工具开发完善中。

  对wasm有较完善的支持。

  - 有依赖管理工具cargo，可以跨平台编译。
  - 安全问题编译器会代替大量在这块的人肉code review。
  - clippy规定了代码格式，代替了人肉code review。
  - 单元测试语言本身就支持而不用引入测试框架。

* 通用性

  适合创建功能强大的跨平台命令行工具。

  可以与C/C++，GO，PHP，Python混合编程，互相调用。也有各语言的代码转换工具。

  https://blog.csdn.net/guiqulaxi920/article/details/78653054

* 并发性

  有std::thread标准库。

  “安全共享可变状态”：不允许线程修改外部的可变数据；只有实现Send接口的数据，才能够在线程间转移所有权；使用“通道”同步多个线程。

## 立项依据

### WebAssembly

#### Webassembly工作原理及工具

* 编译器的“前端”将高级编程语言转换为IR。编译器的“后端”将 IR 转换成目标机器的汇编代码

  ![IR](http://p0.qhimg.com/t01563931f19d4052a3.png)

* 编译

  * 当前对 WebAssembly 支持最多的编译器工具链称是 LLVM。有许多不同的“前端”和“后端”可以插入到 LLVM 中

  * 假设我们想通过 C 来创建 WebAssembly。我们可以使用 clang “前端” 从 C 编译成 LLVM 中间代码。当它变成 LLVM 的中间代码（IR）以后，LLVM 可以理解他，所以 LLVM 可以对代码做一些优化

  * 如果想让 LLVM 的 IR 变成 WebAssembly，我们需要一个 “后端”。目前 LLVM 项目中有一个正在开发中的。这个“后端”对做这件事情很重要，应该很快就会完成。当然现在还未实现

  * ![img](http://p0.qhimg.com/t017e3ca870c9d84649.png)

    （最好能修改一下这个图，变为Rust以及相关的front—end）

##### webassembly在浏览器端的工作过程

链接：https://www.techug.com/post/how-webassembly-works.html

JS引擎中运行javascript代码流程：（代表：V8引擎，使用JIT技术）

![](http://static.webhek.com/techug/uploads/2017/03/wKioL1jOlveQJ1PWAAAXhs_NAzg367.jpg)





- Parsing——表示把源代码变成解释器可以运行的代码所花的时间;（文本文件->语法树）
- Compiling + optimizing——表示基线编译器和优化编译器花的时间。一些优化编译器的工作并不在主线程运行，不包含在这里。
- Re-optimizing——当 JIT 发现优化假设错误，丢弃优化代码所花的时间。包括重优化的时间、抛弃并返回到基线编译器的时间。
- Execution——执行代码的时间
- Garbage collection——垃圾回收，清理内存的时间

webassembly运行流程

![](http://static.webhek.com/techug/uploads/2017/03/wKioL1jOmLLx19eRAAA2CTWwrt8118.png)

WebAssembly 比 JavaScript 执行更快的原因：

- 文件抓取阶段，WebAssembly 比 JavaScript 抓取文件更快。即使 JavaScript 进行了压缩，WebAssembly 文件的体积也比 JavaScript 更小;
- 解析阶段，WebAssembly 的解码时间比 JavaScript 的解析时间更短;
- 编译和优化阶段，WebAssembly 更具优势，因为 WebAssembly 的代码更接近机器码，而 JavaScript 要先通过服务器端进行代码优化。
- 重优化阶段，WebAssembly 不会发生重优化现象。而 JS 引擎的优化假设则可能会发生“抛弃优化代码<->重优化”现象。
- 执行阶段，WebAssembly 更快是因为开发人员不需要懂太多的编译器技巧，而这在 JavaScript 中是需要的。WebAssembly 代码也更适合生成机器执行效率更高的指令。
- 垃圾回收阶段，WebAssembly 垃圾回收都是手动控制的，效率比自动回收更高。

##### 相关开发工具

* WABT: WebAssembly 二进制工具

  * 这个工具可以将二进制的 WebAssembly 代码和人类可以阅读的文本格式代码相互转换。文本格式代码类似于 [S-expression](https://en.wikipedia.org/wiki/S-expression)，这种文本格式的代码可以方便 WebAssembly 的编译器输出并进行分析和调试。

  * wasm2wast 工具：这个工具将 WebAssembly 二进制转换为 S-expressions。他是命令行工具，一个二进制文件作为输入，输出一个包含可以读文本的文件

    开发者可以编辑文本文件，然后再将其转换为二进制文件，比如优化算法、追踪问题、插入调试语句等等。

  * wast2wasm 工具：这个命令行工具和 wasm2wast 是反的。也就是说，它将一个 S-expression WAST 文件转换为二进制的 WebAssembly 文件。

    使用 wasm2wast 和 wast2wasm 可以掌控 WebAssembly 的二进制代码，开发者可以通过工具来操作修改 WebAssembly 的二进制代码

  * wasm-interp 工具:这个工具是个可以让 WebAssembly 二进制代码在命令行中运行的翻译器。它实现了基于堆栈机的解释器，直接解释 WebAssembly 二进制文件。和浏览器将 WebAssembly 二进制通过JIT转换成目标机器的原生代码不一样的是，他不需要加载时间。

    这个解释器对单元测试、检测二进制文件可用性等等很有用。是脱离浏览器的一个环境。

* Binaryen

  * 一套全面的工具，用作将WebAssembly作为输出格式定位的编译器的后端。它具有 C API 和一套自己的逻辑程序的中间表示(IR)，并可以在 IR 上执行一些优化，支持代码合并等。

  * 比如，binaryen 使用了 asm2wasm 作为编译器，将 asm.js 转换成 WebAssembly 文件。它还支持 LLVM 编译器的基础架构，可以将Rust 转换成 WebAssembly。

    通过 binaryen，可以进行编译、优化，它提供了一个壳，可以解释 WebAssembly代码，汇编和反汇编，可以将 asm.js 和 LLVM .s 文件转换成 WebAssembly 等等。

* AssemblyScript

  * 支持直接将TypeScript编译成WebAssembly

* Emscripten：

  * 将其他的高级语言，编译成WebAssembly。

#### 为何优于JavaScript

* 文件加载 - WebAssembly 文件体积更小，所以下载速度更快。

* 解析 - 解码 WebAssembly 比解析 JavaScript 要快

* 编译和优化 - 编译和优化所需的时间较少，因为在将文件推送到服务器之前已经进行了更多优化，JavaScript 需要为动态类型多次编译代码

* 重新优化 - WebAssembly 代码不需要重新优化，因为编译器有足够的信息可以在第一次运行时获得正确的代码

* 执行 - 执行可以更快，WebAssembly 指令更接近机器码

* 垃圾回收 - 目前 WebAssembly 不直接支持垃圾回收，垃圾回收都是手动控制的，所以比自动垃圾回收效率更高。

* 当前状态：四大浏览器宣布支持WebAssembly

  ![Browsers](http://p0.qhimg.com/t0148ea3544a57b6757.png)

* 性能对比

  * 下面的图是Unity WebGL使用和不使用WebAssembly的起步时间对比的一个BenchMark，给大家当作一个参考。可以看到，在FireFox中，WebAssembly和asm.js的性能差异达到了2倍，在Chrome中达到了3倍，在Edge中甚至达到了6倍。通过这些对比也可以从侧面看出，目前所有的主流浏览器都已经支持WebAssembly V1（Node >= 8.0.0）

    ![img](https://img2018.cnblogs.com/blog/1158320/201811/1158320-20181108143238528-2136196189.png)

  * 与JavaScript做对比：分别对比WebAssembly版本和原生JavaScript版本的递归无优化的Fibonacci函数，下图是这两个函数在值是45、48、50的时候的性能对比，几乎稳定的是JavaScript的两倍

    ![img](https://img2018.cnblogs.com/blog/1158320/201811/1158320-20181108143257319-1327221268.png)

### Rust

#### rust相比于其他语言(java)的优势，为何要改写

来源——https://blog.csdn.net/csdnnews/article/details/86570676

​				和 C++ 相比，我为什么要选择 Rust 来开发软件？

- **低功耗：Rust 是少数非常适合在非常低功耗的嵌入式系统的极其受限的资源上运行的语言之一。**
- web方面应用：Rust 其中有些应用程序提供的功能是使用 JavaScript无法实现的。Rust 可以编译成 WebAssembly，它以接近原生的速度在每个主要的 Web 浏览器中运行。有一些工具允许你通过 WebAssembly 将 Rust 代码发送到 npm（JavaScript 包存储库），然后透明地向下游用户发送，还可以通过绑定将 Rust 部署到 Web 上，这允许调用浏览器和 JavaScript 本身提供的大多数功能。
- 分布式在线服务：对于网络服务， Rust 可以使用最少资源来确保跨多个线程的内存安全，同时 Rust 还使得编写泄漏内存或其他资源的代码变得更加困难，这些方面可以降低服务器成本并降低运营负担。

#### Rust与webassembly的契合点

***

### 浏览器

#### 内核调用及web前端实现原理

浏览器内核简介：

浏览器可以分为两部分，shell+内核。Shell是指浏览器的外壳：例如菜单，工具栏 等。主要是提供给用户界面操作，参数设置等等，它是调用内核来实现各种功能的。内核是基于标记语言显示内容的程序或模块。

浏览器内核又可以分成两部分：渲染引擎(layout engineer或者Rendering Engine)和JS引擎。

渲染引擎负责取得网页的内容（HTML、XML、图像等等）、整理讯息（例如加入CSS等），以及计算网页的显示方式，然后会输出至 显示器或打印机。

JS引擎则是解析Javascript语言，执行javascript语言来实现网页的动态效果。

常见的浏览器内核可以分这四种：Trident、Gecko、 Presto、Webkit。

**JS引擎：**

- Trident又称MSHTML，是微软开发的渲染引 擎（包含了Javascript引擎JScript），已经深入了Windows操作系统的骨髓，例如Windows Media Play，Windows Explorer，Outlook Express等都使用了。

  例如IE,MaxThon,TT,The World,360,搜狗浏览器等

- Gecko是C++开发的，Open Source的渲染引擎，包括了SpiderMonkey(Rhino)。

  例如Netscape6及以上版本，FF,MozillaSuite/SeaMonkey等

- Webkit是苹果公司基于KHTML开发的。他包括Webcore和JavaScriptCore（SquirrelFish,V8）两个引擎。

  例如Safari，Chrome。

- Presto由Opera Software公司开始的，用于Opera的渲染引擎。Macromedia Dreamweaver （MX版本及以上）和Adobe Creative Suite 2也使用了Presto的内核。

  例如Opera7及以上（图片在这里！！！）

  ![](D:\科大\大二下\操作系统\调研报告\Rust,文件上传下载\image-20200308232201853.png)

  #### 调用浏览器内核

  #### 一、浏览器组成

  ##### **1. 浏览器内核定义**

  维基百科中无该词条。大部分资料表示“浏览器内核”可以指JS引擎和渲染引擎；由于JS引擎越来越独立，所以现多指渲染引擎。

  #####  **2. 浏览器组成**概要 

  ![](https://upload-images.jianshu.io/upload_images/7707397-d5be1fbce7de7af4.png?imageMogr2/auto-orient/strip|imageView2/2/format/webp)

  浏览器的抽象分层结构图中将浏览器分成了以下8个子系统：

  ##### **用户界面（User Interface）**

  用户界面主要包括工具栏、地址栏、前进/后退按钮、书签菜单、可视化页面加载进度、智能下载处理、首选项、打印等。除了浏览器主窗口显示请求的页面之外，其他显示的部分都属于用户界面。

  用户界面还可以与桌面环境集成，以提供浏览器会话管理或与其他桌面应用程序的通信。

  ##### **浏览器引擎（Browser Engine）**

  浏览器引擎是一个可嵌入的组件，其为渲染引擎提供高级接口。

  浏览器引擎可以加载一个给定的URI，并支持诸如：前进/后退/重新加载等浏览操作。

  浏览器引擎提供查看浏览会话的各个方面的挂钩，例如：当前页面加载进度、JavaScript alert。

  浏览器引擎还允许查询/修改渲染引擎设置。

  ##### **渲染引擎（Rendering Engine）**

  渲染引擎为指定的URI生成可视化的表示。

  渲染引擎能够显示HTML和XML文档，可选择CSS样式，以及嵌入式内容（如图片）。

  渲染引擎能够准确计算页面布局，可使用“回流”算法逐步调整页面元素的位置。

  渲染引擎内部包含HTML解析器。

  ##### **网络（Networking）**

  网络系统实现HTTP和FTP等文件传输协议。 网络系统可以在不同的字符集之间进行转换，为文件解析MIME媒体类型。 网络系统可以实现最近检索资源的缓存功能。

  ##### **JavaScript解释器（JavaScript Interpreter）**

  JavaScript解释器能够解释并执行嵌入在网页中的JavaScript（又称ECMAScript）代码。 为了安全起见，浏览器引擎或渲染引擎可能会禁用某些JavaScript功能，如弹出窗口的打开。

  ##### **XML解析器（XML Parser）**

  XML解析器可以将XML文档解析成文档对象模型（Document Object Model，DOM）树。 XML解析器是浏览器架构中复用最多的子系统之一，几乎所有的浏览器实现都利用现有的XML解析器，而不是从头开始创建自己的XML解析器。

  ##### **显示后端（Display Backend）**

  显示后端提供绘图和窗口原语，包括：用户界面控件集合、字体集合。

  ##### **数据持久层（Data Persistence）**

  数据持久层将与浏览会话相关联的各种数据存储在硬盘上。 这些数据可能是诸如：书签、工具栏设置等这样的高级数据，也可能是诸如：Cookie，安全证书、缓存等这样的低级数据。

  这里可能会产生一个疑问：功能相似的HTML解析器和XML解析器为什么前者划分在渲染引擎中，后者作为独立的系统？

  原因：XML解析器对于系统来说，其功能并不是关键性的，但是从复用角度来说，XML解析器是一个通用的，可重用的组件，具有标准的，定义明确的接口。相比之下，HTML解析器通常与渲染引擎紧耦合。

  

  ##### **3. 渲染引擎详解**

  链接：

  渲染引擎（浏览器内核）兼容性问题：https://blog.csdn.net/qq_21342217/article/details/48314083 

  渲染引擎工作原理：https://kb.cnblogs.com/page/129756/ （非常详细）

  ##### **3.1 渲染主流程**（The main flow）

  渲染引擎首先通过网络获得所请求文档的内容，通常以8K分块的方式完成。

  下面是渲染引擎在取得内容之后的基本流程：

  解析html以构建dom树 -> 构建render树 -> 布局render树 -> 绘制render树

  ![](https://pic002.cnblogs.com/images/2011/265173/2011110316263715.png)

  **3.2 主流浏览器的渲染引擎**

  浏览器的组成模块众多，而渲染引擎则是浏览器中最重要的模块（渲染引擎有时候也被称为“浏览器内核”，这种说法并不严谨，不推荐使用）。目前，常见的渲染引擎有Trident、Gecko、WebKit等。下表所示为几种渲染引擎在不同浏览器中的应用：

  - **Trident(IE内核)**
    Trident内核代表产品Internet Explorer，又称其为IE内核。Trident（又称为MSHTML），是微软开发的一种排版引擎。国内很多的双核浏览器其中之一就是Trident，美名其曰“兼容模式”。
    代表：IE、傲游、世界之窗浏览器、Avant、猎豹安全浏览器、360极速浏览器、百度浏览器等。
    Window10发布后，IE将其内置浏览器命名为Edge（原名斯巴达），使用了新内核Edge引擎。

  - **Gecko（Firefox）**
    Gecko内核代表作品Mozilla FirefoxGecko是一套开放源代码的、以C++编写的网页排版引擎。Gecko是最流行的排版引擎之一，仅次于Trident。使用它的最著名浏览器有Firefox、Netscape6至9。可惜这几年已经没落了，比如打开速度慢、升级频繁、猪一样的队友flash、神一样的对手Chrome。

  - **Webkit（Safari）**
    苹果公司自己的内核，也是苹果的Safari浏览器使用的内核。
    WebKit内核代表作品Safari、Chromewebkit 是一个开源项目，包含了来自KDE项目和苹果公司的一些组件，主要用于Mac OS系统，它的特点在于源码结构清晰、渲染速度极快。缺点是对网页代码的兼容性不高，导致一些编写不标准的网页无法正常显示。主要代表作品有Safari和Google的浏览器Chrome。

    WebKit是一种用来让[网页浏览器](https://zh.wikipedia.org/wiki/网页浏览器)[绘制](https://zh.wikipedia.org/wiki/渲染)[网页](https://zh.wikipedia.org/wiki/網頁)的[排版引擎](https://zh.wikipedia.org/wiki/排版引擎)。它被用于[Apple](https://zh.wikipedia.org/wiki/蘋果公司) [Safari](https://zh.wikipedia.org/wiki/Safari)。其分支[Blink](https://zh.wikipedia.org/wiki/Blink)被用于基于[Chromium](https://zh.wikipedia.org/wiki/Chromium)的网页浏览器，如：[Opera](https://zh.wikipedia.org/wiki/Opera)与[Google Chrome](https://zh.wikipedia.org/wiki/Google_Chrome)。

  - **Presto（Opera）**
    Presto内核代表作品OperaPresto是由Opera Software开发的浏览器排版引擎，供Opera 7.0及以上使用。它取代了旧版Opera 4至6版本使用的Elektra排版引擎，包括加入动态功能，例如网页或其部分可随着DOM及Script语法的事件而重新排版。在13年之后，Opera宣布加入谷歌阵营，弃用了Presto。

  - **Blink（Chrome）**
    有Google和Opera Software开发的浏览器排版引擎，2013年4月发布，现在Chrome内核是Blink。Blink其实是webkit的分支，大部分国产浏览器最新版都采用Blink内核。

  移动端的浏览器内核主要说的是系统内置浏览器的内核。
  目前移动设备浏览器上常用的内核有Webkit、Blink、Trident、Gecko，其中苹果iOS平台主要是Webkit，Android4.4之前Android系统浏览器的内核是Webkit，Android4.4之后使用Blink，Windows Phone 8系统浏览器内核是Trident。

  #### 4. JS引擎详解

  **4.1 概念辨析：JavaScript引擎、虚拟机、运行时环境**

  链接：https://www.zhihu.com/question/39499036/answer/82134118
  来源：知乎

  ![](https://pic3.zhimg.com/80/2a172876a47e1ea0a1a2ceba4abfbf81_1440w.jpg)

  紫色部分是虚拟机，紫色加灰色是引擎。运行时可以认为在虚拟机内部。

  更易懂的解释：

  引擎，类似开车，引擎是一个组件，有输入输出，汽车引擎的输入是油、空气，输出是扭矩、热、废气，一个引擎得可接输油管、进气口管，输出得接齿轮组（变速箱）、水箱、排气管，这些其实是API，即引擎是有可供操作API的。

  虚拟机，对应引擎其实是内置气缸（内燃机），其主要目的是内燃能量转换，（当然内燃机只是其中一种正如虚拟机类型不同一样），通过曲柄，火花塞，混合器、雾化器等组件来达到这一目的，翻译过来，就是通过一系列手段，将代码剖析后运行起来，这是引擎的核心组件。

  运行时，上面这些东西总要在实际环境中跑，跑的时候就是运行时，环境则为外部冷热度，水箱是否有水，是否有润滑油，电池是否有电等等（电打火），对应就是，一组外部约束，用来检测代码在当前环境中，安全性、权限等等的东西，比如 node 运行时，和 浏览器运行时区别。

  **4.2 主流JS引擎**

  ![](https://image-static.segmentfault.com/411/560/4115604784-5aa67274b8c3b_articlex)

  JS引擎工作机制：https://www.cnblogs.com/onepixel/p/5090799.html

  #### 5. 页面呈现原理

  链接：https://segmentfault.com/a/1190000013681721

  webkit渲染引擎流程如图：

  ![](https://upload-images.jianshu.io/upload_images/3534846-00ef9f3d405462ef.png?imageMogr2/auto-orient/strip|imageView2/2/w/624/format/webp)

  一个页面的呈现，粗略的说会经过以下这些步骤：

  ```
  1. DOM 树的构建（Parse HTML）
  2. 构建 CSSOM 树（Recaculate Style） 为什么是 Re-caculate Style 呢？这是因为浏览器本身有 User Agent StyleSheet，所以最终的样式是我们的样式代码样式与用户代理默认样式覆盖/重新计算得到的。
  3. 合并 DOM 树与 CSSOM 树为 Render 树
  4. 布局（Layout）
  5. 绘制（Paint）
  6. 复合图层化（Composite）图层化是自己理解后形象的意译其中布局（Layout）环节主要负责各元素尺寸、位置的计算，绘制（Paint）环节则是绘制页面像素信息，合成（Composite）环节是多个复合层的合成，最终合成的页面被用户看到。
  ```

  - **（webassembly比 JS 效率更高的好处，wasm更快）**当遇到 JavaScript 脚本或者外部 JavaScript 代码时，浏览器便停止 DOM 的构建（阻塞 1）

  那是否停下 DOM 的构建的同时，立马就执行 JavaScript 代码或者下载外部脚本执行，其实还是要视情况而定，见2（另有一些资料表示遇到javascript代码就会停止构建DOM树）

  - 当遇到 /<script> 标签需要执行脚本代码时，浏览器会检查是否这个 <script> 标签以上的 CSS 文件是否已经加载并用于构建了 CSSOM，如果 <script> 上部还有 CSS 样式没加载，则浏览器会等待 <script> 上方样式的加载完成才会执行该 <script> 内的脚本（阻塞 2）
  - DOM 树与 CSSOM 树的成功构建是后面步骤的根基（同步阻塞）
  - 同时外部脚本、外部样式表的下载也是耗费时间较多的点

#### 文件上传与下载

作者：清晓凝露
链接：https://www.jianshu.com/p/374e9b9d1fb1

作者：谭伟华

链接：https://cloud.tencent.com/developer/article/1004961

- 开源的拿来即用的前端上传插件比较多，诸如:Web Uploader、JSAjaxFIleUploader、
  jQuery-File-Upload，通常这些上传插件包含的功能有：选择上传、支持拖拽、MD5校验、图片预览、上传进度显示等功能

- 高版本浏览器采用ajax（Asynchronous JavaScript and XML）方式，低版本浏览器采用iframe+form表单形式(最原始的方式form元素表单提交，发展后form原始+iframe实现异步文件上传)

  标准浏览器通过 `XMLHttpRequest` 对象实现了ajax的功能. 只需要通过一行语句便可创建一个用于发送ajax请求的对象； IE浏览器通过 `XMLHttpRequest` 或者 `ActiveXObject` 对象同样实现了ajax的功能.。

  - **form表单提交：form表单属性中，action属性规定后端处理文件上传的路径；method属性规定上传文件的方法post or get；enctype属性规定在发送到服务器之前应该如何对表单数据进行编码，在使用包含文件上传控件的表单时必须使用“multipart/form-data”。**

  - **iframe封装form表单：使用form元素比较简单，但缺点也比较明显：上传同步、上传完成页面会刷新；**

    **在HTML5出现之前，想要实现文件异步上传，只能通过iframe+form实现;**

    **原理:文件上传时在页面中动态创建一个iframe元素和一个form元素，并将form元素的[target](https://link.jianshu.com?t=http://www.w3school.com.cn/tags/att_form_target.asp)属性指向动态创建iframe元素。当用户完成选择文件动作时，提交子页面中的 form。这时，iframe跳转，而父页面没有刷新。这使得上传结束后，服务器处理结果返回到动态iframe窗口而没有刷新页面。**

    **上传结果处理需要前后端配合。**

    **1.前后端预先约定好回调函数名；**

    **2.前端页可以监听frame 的onLoad确定是否请求超时和后端是否给予返回；**

- FormData ajax：利用FormData对象，我们可以通过JavaScript用一些键值对来模拟一系列表单控件，我们还可以使用XMLHttpRequest的send()方法来异步的提交这个"表单"。比起普通的ajax，使用FormData
  的最大优点就是我们可以异步上传一个二进制文件。

- 拖拽上传：确定一个允许拖放的区域，然后绑定相应的事件进行处理。（代码见原网址）

- 上传进度：XMLHttpRequest Level 2中，上传数据的时候，有一个progress事件，属于XMLHttpRequest.upload对象。event.total是需要传输的总字节；event.loaded是已经传输的字节；如果event.lengthComputable不为真，则event.total等于0。对于低版本浏览器则可以用通过轮询的方式获取上传进度。

  XHR对象的直属progress事件是用来监听加载资源的进度的。XMLHttpRequestUpload 对象是上传资料，其中onprogress 事件回调方法可用于跟踪资源上传的进度，它的event参数对象包含两个属性loaded和total，分别代表当前已上传的字节数（number of bytes）和文件的总字节数。

- 支持多浏览器文件上传：

  https://blog.csdn.net/qiao1245/article/details/45335991	JavaScript浏览器访问/上传本地文件  yang1young使用FileSystemObject（具体代码见网址）

  - 使用javascript 的API：

    由于不使用activx插件，因而使用起来更加方便。
    File API 基本功能是实现用 JavaScript 对本地文件进行操作。出于安全性的考虑，该 API 只对本地文件提供有限的访问。它可以很轻松的用纯 JavaScript 来实现本地文件的读取和上传。FireFox 3.6 是最先支持这一功能的，最新版本的 Google Chrome 浏览器和 Safari 浏览器也有相应的支持。

    > 常用方法
    >
    > readAsBinaryString()     
    > 读取文件内容，读取结果为一个 binary string。文件每一个 byte 会被表示为一个 [0..255] 区间内的整数。函数接受一个 File 对象作为参数。
    > readAsText()     
    > 读取文件内容，读取结果为一串代表文件内容的文本。函数接受一个 File 对象以及文本编码名称作为参数。
    > readAsDataURL    读取文件内容，读取结果为一个 data: 的 URL。
    >
    > 常用方法
    >
    > Onloadstart  文件读取开始时触发。
    > Progress     当读取进行中时定时触发。事件参数中会含有已读取总数据量。
    > Abort    当读取被中止时触发。
    > Error    当读取出错时触发。
    > Load     当读取成功完成时触发。
    > Loadend  当读取完成时，无论成功或者失败都会触发。
    >
    > （原网址上还有一些实现的相应代码）

  - XMLHttpRequest Level 2：现代网页实现用户与服务器的无刷新交互的方式

    - 支持二进制数据, 可以上传文件, 可以使用FormData对象管理表单.
    - 提供进度提示, 可通过 xhr.upload.onprogress 事件回调方法获取传输进度.
    - 依然受 同源策略 限制, 这个安全机制不会变. XHR2新提供 Access-Control-Allow-Origin 等headers, 设置为 * 时表示允许任何域名请求, 从而实现跨域CORS访问(有关CORS详细介绍请耐心往下读).
    - 可以设置timeout 及 ontimeout, 方便设置超时时长和超时后续处理.

- 图片预览：普通的图片预览方式是待文件上传成功后，后台返回上传文件的url，然后把预览图片的img元素的src指向该url。这其实达不到预览的效果和目的。应使用HTML5的FileReader API（有代码）：使用FileReader来处理图片的异步加载。在创建新的FileReader对象之后，建立onload函数，然后调用readAsDataURL()开始在后台进行读取操作。当图像文件加载后，转换成一个 data: URL，并传递到onload回调函数中设置给img的src。另外还可以通过使用对象URL来实现预览

- 多文件支持：<input id="myFile" type="file" multiple>

- 二进制上传：（code）

注：可扩展标记语言，标准通用标记语言的子集，简称XML

- 文件下载

  - 原生提交，后端返回文件流：利用form.submit直接向后端提交,后端返回文件流生成的文件，后端处理成功后会直接返回到页面，浏览器会整理并打开下载文件 。
    优点 ：没有兼容问题，传统方式
    缺点：无法得到后端处理这个过程的时机，无法根据回调函数做交互以及进度提示

  - ajax提交，后端返回在线文件地址：利用ajax或者新生的axios去提交请求，后端会返回一个线上的文件地址，前端可以通过原生的window.open打开这个地址就可以实现下载；也可以通过a标签设置href以及download属性，并自动点击实现其下载功能，关于其兼容性问题，可以判断download属性是否存在来弥补。
    优点 ：可以拿到其返回时机，可以做交互
    缺点 ：线上会存储大量的中间临时文件，可以用设置时限来优化。另外涉及用户隐私的问题，可以用token等验证机制实现。

  - 前端利用download模块进行下载：其对应的下载文件方案包括了以下几种。

    window.open(url)打开某个文件地址
    iframe的框架中，设置src属性，通过iframe进行文件的下载，支持文件地址
    通过form标签，设置action的文件地址，然后通过form的提交来完成文件的下载（支持二进制）

    对于常规的支持文件地址的下载，兼容性非常好，而对于传统的文件流性质的，通过form标签也可以进行简单的支持。



***

## 重要性/前瞻性分析

* 基于Rust对Ceph或17级大作业进行重写
  * Rust的优势（插入）
* 在浏览器上实现分布式运行该系统，实现文件的交互
  * 用WebAssembly进行转码，基于浏览器的跨平台性，实现分布式文件系统的跨平台使用
* 补充相关的插件，丰富功能

### WebAssembly

#### 发展趋势，面临的难题

#### 社会需求，与我们的需求的契合

#### WebAssembly 适合用于需要大量计算的场景，例如：

* 在浏览器中处理音视频，[flv.js](https://github.com/Bilibili/flv.js/) 用 WebAssembly 重写后性能会有很大提升
* React 的 dom diff 中涉及到大量计算，用 WebAssembly 重写 React 核心模块能提升性能。Safari 浏览器使用的 JS 引擎 JavaScriptCore 也已经支持 WebAssembly，RN 应用性能也能提升
* 突破大型 3D 网页游戏性能瓶颈、

***

### Rust

#### 发展趋势及学习需求

#### 存在的问题

#### 学习难度，改写的可行性

***

### 浏览器

#### V8内核，Node.js原理及对webassembly,js,rust的支持



#### js，webassembly，rust结合点

## 相关工作

***



### Rust

* **相关工作，成功案例**

  来源———http://blog.csdn.net/liigo/article/details/45757123 

  ​					为什么我说Rust是靠谱的编程语言 Liigo（庄晓立）

  - Servo: 下一代浏览器渲染引擎（类Webkit/Blink），超过25万行Rust代码。

    Servo启动于2012年初，跟Rust并行开发。对于Rust而言，Servo项目存在的最大意义就是，它实践并印证了Rust语言具有实际的大中型项目开发能力。Servo已经通过了 Acid2 标准测试；可以 并发渲染 Github/Reddit/CNN 这类大型静态网页，性能 明显高于 当前的Firefox浏览器的Gecko引擎；可以无缝替换基于Chrome的CEF 框架；已经实验性的应用在Firefox OS平台(b2s)。2015年将发布测试版浏览器。Servo有机会成为浏览器历史上里程碑式的产品。

  - rustc+std: Rust编译器和标准库，超过30万行Rust代码。

    时至今日，rustc负责编译全世界所有的Rust源代码，包括rustc+std的30万行和servo的25万行，以及crates.io网站上的2000多个第三方库，是名副其实的大型成功项目。

  - Cargo: Rust的package管理器，项目依赖管理。

    代码量相比前两者而言要小的多，代码虽少，但实用性、流行度有过之而无不及。全世界大约99%的Rust项目采用Cargo编译。crates.io网站上有2000多个包，总下载量超150万次。Cargo最大幅度地简化了Rust项目的编译和依赖管理，可以说是目前开发Rust项目的必备工具。

##### 使用Rust开发的项目

* TiKV

  分布式存储数据库。

* Servo

  https://github.com/servo/servo/

  Servo是高性能、并行浏览器引擎。适用于浏览器应用和嵌入式应用。

  Servo采用Rust编程语言编写，使浏览器内部有高性能和内存安全性，大幅减少影响浏览器引擎的关键错误数量。采用模块化架构，目前可运行在Linux、macOS、Windows和Android操作系统上。





##### 参考网站

* https://baijiahao.baidu.com/s?id=1622998388358453257&wfr=spider&for=pc
* https://www.techrepublic.com/article/rust-programming-language-seven-reasons-why-you-should-learn-it-in-2019/
* https://www.rust-lang.org/
* https://www.zhihu.com/question/362330696/answer/947113477
* https://www.zhihu.com/question/30407715/answer/48032883

* https://wiki.jikexueyuan.com/project/rust/concurrency.html
* https://www.jianshu.com/p/e963d92c5697
* https://rust.cc/article?id=37bfd307-b273-4147-9548-0edd670a8b7d



##### 往年用到Rust的项目

* https://github.com/OSH-2019/x-rust-freertos/blob/master/docs/feasibility.md
* https://github.com/OSH-2019/x-i-m-feeling-lucky/blob/master/docs/feasibility.md#3-rust-programming-language

调研、可行性报告中关于rust的部分：与项目关联点，关于rust特有语法的理解和解释

### webassembly

* 在大型项目中的应用

  * AutoCAD

    * 一个用于画图的软件，在很长的一段时间是没有Web的版本的，原因有两个，其一，是Web的性能的确不能满足他们的需求。其二，在WebAssembly没有面世之前，AutoCAD是用C++实现的，要将其搬到Web上，就意味着要重写他们所有的代码，这代价十分的巨大。

      而在WebAssembly面世之后，AutoCAD得以利用编译器，将其沉淀了30多年的代码直接编译成WebAssembly，同时性能基于之前的普通Web应用得到了很大的提升。正是这些原因，得以让AutoCAD将其应用从Desktop搬到Web中。

  * Google Earth

    * Google Earth也就是谷歌地球，因为需要展示很多3D的图像，对性能要求十分高，所以采取了一些Native的技术。最初的时候就连Google Chrome浏览器都不支持Web的版本，需要单独下载Google Earth的Destop应用。而在WebAssembly之后呢，谷歌地球推出了Web的版本。而据说下一个可以运行谷歌地球的浏览器是FireFox

  * Unity和Unreal游戏引擎

* 不止于浏览器:WebAssembly 作为一种底层字节码，除了能在浏览器中运行外，还能在其它环境运行。

  * 直接执行 wasm 二进制文件

    *  Binaryen 提供了在命令行中直接执行 wasm 二进制文件的工具，在 Mac 系统下通过 brew install binaryen 安装成功后，通过 wasm-shell f.wasm 文件即可直接运行。

  * 在 Node.js 中运行

    * 目前 V8 JS 引擎已经添加了对 WebAssembly 的支持，Chrome 和 Node.js 都采用了 V8 作为引擎，因此 WebAssembly 也可以运行在 Node.js 环境中；

      V8 JS 引擎在运行 WebAssembly 时，WebAssembly 和 JS 是在同一个虚拟机中执行，而不是 WebAssembly 在一个单独的虚拟机中运行，这样方便实现 JS 和 WebAssembly 之间的相互调用。w

    * 通过 C、Rust 去编写 WebAssembly，可直接编译成 Nodejs 可以调用的原生模块。

* 安装WebAssembly Rust工具链（待完成）

* Rust and WebAssembly (a small project):https://zcfy.cc/article/get-started-with-rust-webassembly-and-webpack-ian-j-sikes-medium-3345.html?t=new

####  白鹭引擎

视频链接：https://www.youtube.com/watch?v=HaO3l287y-I

1. **背景知识**

   - 可视化开发工具：Egret Wing、Dragonbones、Egret Paper
     命令行脚本：项目模板、编译器( Base on TypeScript ) 、资源管理框架
     核心JavaScript运行时库：2D/ 3D渲染库、动画/粒子/物理库、其他

   - HTML 5 游戏引擎：开发效率、加载效率、**运行效率**（webassembly提升的地方）

   - 渲染内核原理

     ![](D:\科大\大二下\操作系统\调研报告\浏览器内核 webassembly调研-刘逸菲\图片\1.png)

   ![](D:\科大\大二下\操作系统\调研报告\浏览器内核 webassembly调研-刘逸菲\图片\2.png)

例：用户逻辑：每一帧向下移一像素

​		引擎逻辑：将用户的“向下移一个像素”转换成浏览器底层渲染API了解的，比如：矩阵变换

​		渲染逻辑：将结果传给WebGL接口

2014年，由于浏览器的接口很差，渲染很慢，所以性能由“渲染逻辑”决定。通过webGL，硬件优化等等，浏览器内核内核提升后，性能问题转换到“引擎逻辑”。那么如何进一步提升javascript的运行效率？

虽然V8 JS引擎中的 JIT 使得javascript的效率大幅增加，但效率已经被压榨到了极限，web开发者开始考虑重新设计一门web用的语言，那么他应该有下面三个特性：

- 面向机器，而非面向开发者。不应该是文本，可以编译成汇编
- 强类型，而非运行时推断类型
- 使用更可控的垃圾回收机制：垃圾回收会让整个JS引擎停止，所以垃圾回收不应该交给虚拟机做

2. **webassembly架构**

   ![](D:\科大\大二下\操作系统\调研报告\浏览器内核 webassembly调研-刘逸菲\图片\3.png)

![webassembly 工作方式](https://pic4.zhimg.com/a3d0d0e45057489e78b70620b739bb74_r.jpg)



两层编译的好处：支持webassembly的浏览器可以直接运行.wasm，不支持的浏览器可以运行.asm.js 

3. **webassembly在游戏引擎中的应用**

   几种可能的实现方法：

   - Native 浏览器插件：相对性能最高，但不是HTML 5标准 eg. Flash player 

   - JavaScript + HTML5 API（现在的HTML5游戏引擎采用）

   - Native Code to Webassembly

     理论上可以，但不现实。原生游戏体积大，游戏开始时就要下载很多资源，不现实。此外，还要考虑web的一些特性，难以实现。

   - JavaScript API + WebAssembly Core （白鹭引擎采用）

     上层JS，引擎渲染内核为webassembly，可以正常用js的API

   **白鹭引擎webassembly内核核心原理：**

   - 白鹭引擎对外提供JavaScript API

   - 开发者编写的JavaScript逻辑代码会汇总为一组命令队列发送给
     WebAssembly层（即引擎内核层）

   - 然后WebAssembly建立对渲染节点的抽象封装，并在每一帧对
     这些渲染节点进行矩阵计算、渲染命令生成等逻辑

     这个机制与浏览器实现机制相似，创建一棵树，在树上存储所有命令之后再重新生成，然后计算每一帧的渲染节点，Javascript中计算矩阵慢，而webassembly快

   - 生成组ArrayBuffer数据流

     由于Webassembly和javascript交互很差，所以用arraybuffer(相当于JS和Webassembly都可以用的内存)来传递数据

   - 最后JavaScript对这组数据流（webassembly渲染出的数据流）进行简单的解析并直接调用DOM的WebGL接口

     由于webassembly不能调用DOM，所以不得不传回 JS 调用

   ![](D:\科大\大二下\操作系统\调研报告\浏览器内核 webassembly调研-刘逸菲\图片\4.png)

   坑

    - JavaScript与WebAssembly的对象互相调用性能很差

      -> 使用ArrayBuffer共享（JS与Webassembly共享）性能有些慢，但可以接受

    - 简单地将特定的几个函数编译为WebAssembly，然后交由JavaScript去调用的方式反而会因为频繁的互相操作反而造成性能下降

      ->进行一次性的密集计算

    - WebAssembly不存在垃圾回收机制

      -> 需要手动删除垃圾，而JavaScript开发者已经习惯于垃圾回收机制

   建议

    - 把密集型大型计算工作交由WebAssembly解决

    - 不建议初期在Emscripten中使用html5.h 等高级特性

  #### 爱奇艺直播

链接：https://cloud.tencent.com/developer/news/464897

爱奇艺生产的直播流有mp4和flv两种格式，但Html5的video标签原生只支持mp4的播放，如何解决flv格式在网页端播放的问题就摆在了所有人的面前。一般来说flv格式在网页端播放有以下几种解决方案：

**1、使用flash播放器插件**

不过因为性能和安全等各种问题，各大浏览器已经逐渐弱化了这种方式，Chrome也将在2020年左右停止对flash player的支持，所以现在基本很少有人用了。

**2、网页对flv格式的视频解码**

使用canvas渲染图像，使用audio播放声音，相当于网页端做一个播放器，这也是可行的。但各大浏览器厂商对原生video控件会针对不同的平台做硬件加速渲染的优化，如果自己渲染的话，硬件加速这块便也需要自己做，这样会耗费极大的人力，并且效果也很难和浏览器原生的硬件加速相比。

**3、在网页端将flv格式转成mp4格式然后使用原生播放器** 

这也是目前使用得最多的方案。这样既可以播放flv的直播流，也可以将渲染丢给原生播放器去做，充分发挥原生播放器的优化能力。

爱奇艺直播使用的就是第三种方式，当flv的直播流到达前端时，使用JavaScript将flv转换成mp4，再交给原生播放器。但由于JavaScript运行效率较低，这部分的性能一直都令人不太满意，所以决定引入WebAssembly技术，看看是否能带来不一样的提升。现在打开任意的爱奇艺直播间，在后面输入__enablewasm__=true，就能打开WebAssembly转码模式。体验上，两种模式都能满足流畅观看直播的需求。由此可见，WebAssembly模块可以很完美地替换原来的JavaScript所写的转码模块。

接入webassembly所需步骤：

 1. 使用C编写flv转mp4的代码

 2. 使用emcc编译出flv2Mp4.js和flv2Mp4.wasm

 3. 对接编译好的wasm文件

    ![](D:\科大\大二下\操作系统\调研报告\浏览器内核 webassembly调研-刘逸菲\图片\5.png)

    效果：

    - 转码速度提升明显
    - cpu占用率下降



## 参考文献

百度百科

CSDN

Google

Wikipedia

WebAssembly中文网

***

### 附录

#### Erasure code

* 擦除编码（简称EC）是一种数据保护方法，其中数据被分解成碎片，并用冗余数据块进行扩展和编码，并存储在一组不同的位置或存储介质中

* EC的目的是使磁盘存储过程中**某个时刻损坏的数据能够通过使用有关存储在阵列其他位置的数据的信息来重建**。擦除码通常可以代替传统RAID使用，因为它们能够减少重建数据所需的时间和开销。擦除编码的缺点是它可能会占用更多CPU资源，并且会转化为增加的延迟

* EC对于大量数据以及需要容忍故障的任何应用程序或系统（例如磁盘阵列系统，数据网格，分布式存储应用程序，对象存储和档案存储）很有用。基于擦除的一种常见的当前用例是基于对象的云存储

* 擦除编码创建一个数学函数来描述一组数字，以便可以检查它们的准确性，如果丢失则可以恢复。称为**多项式插值或过采样**，这是擦除码背后的关键概念。用数学术语，擦除编码提供的保护可以用以下等式简单表示：n = k + m。变量“ k”是数据或符号的原始数量。变量“ m”代表添加的多余或冗余符号，以提供保护以防止故障。变量“ n”是在擦除编码过程之后创建的符号总数。例如，在16之10的配置或EC 10/16中，会将六个额外的符号（m）添加到10个基本符号（k）。16个数据片段（n）将分布在16个驱动器，节点或地理位置上。原始文件可以从10个经过验证的片段中重建。**简单的理解为: 对k个同样大小的数据块, 额外增加m个校验块, 以使得这k+m个数据中任意丢失m个数据块/校验块时都能把丢失的数据找回**

* EC生成校验块的过程称之为EC的**编码**, 也就是用[Vandermonde](https://en.wikipedia.org/wiki/Vandermonde_matrix)矩阵去乘所有的数据块.

  而当数据丢失需要找回的时候, 使用的是EC的**解码**过程.

  既然EC的编码过程是**编码矩阵**([Vandermonde](https://en.wikipedia.org/wiki/Vandermonde_matrix))和数据块列相乘:

  ![](D:\科大\大二下\操作系统\调研报告\分布式+WebAssembly调研-pqz\图片\1.png)

  那么解码的过程就可以描述如下:

  假设有q个数字丢失了, `q <= m`. 从上面的**编码矩阵**中选择q行, 组成的一次方程组, 求解方程组算出丢失的数据.

  例如 `d₂, d₃` 丢失了, 下面用 `u₂, u₃` 表示 (只丢失了2块数据, 不需要所有的m个校验块参与, 只需要2个校验块来恢复数据)

  ![](D:\科大\大二下\操作系统\调研报告\分布式+WebAssembly调研-pqz\图片\2.png)

  这个矩阵表示的方程组里有2个未知数 `u₂, u₃` , 解方程即可得到 `u₂, u₃` 这2块丢失的数据.

  方程组保证有解

  对于k+m的EC来说, 任意丢失m个数据块都可以将其找回. 因为我们选择的[Vandermonde](https://en.wikipedia.org/wiki/Vandermonde_matrix) 矩阵保证了任意`m`行`m`列组成的子矩阵都是线性无关的, 构成的方程肯定有确定解. 例如:

  ![](D:\科大\大二下\操作系统\调研报告\分布式+WebAssembly调研-pqz\图片\3.png)

  - [Vandermonde](https://en.wikipedia.org/wiki/Vandermonde_matrix) 的 行列式的值为:

    ![](D:\科大\大二下\操作系统\调研报告\分布式+WebAssembly调研-pqz\图片\4.png)

    只要 xᵢ 都不同, 则 [Vandermonde](https://en.wikipedia.org/wiki/Vandermonde_matrix) 矩阵的行列式就不为0, 矩阵可逆, 表示方程有唯一解.

  - [Vandermonde](https://en.wikipedia.org/wiki/Vandermonde_matrix) 矩阵的任意 `m x m` 的子矩阵, 是一个Generalized Vandermonde Matrix, 它在 xᵢ 都为正数时可以保证永远有唯一解.

    因此在**实数**领域, 我们总能保证上面这个冗余策略很好的工作

#### 有用链接：

查的过程中发现的其他资料：

webAssembly和rust的结合教程：https://rustwasm.github.io/book/#who-is-this-book-for

ajax book：http://louiszhai.github.io/2016/11/02/ajax/

***



## 冗余

##### FastDFS特性及问题思考

2016年07月24日 01:30:39

​    FastDFS是国人开发的一款分布式文件系统，目前社区比较活跃。**系统中存在三种节点：Client、Tracker、Storage，在底层存储上通过逻辑的分组概念，使得通过在同组内配置多个Storage，从而实现软RAID10，提升简单负载均衡、并发IO的性能、及数据的冗余备份；同时通过线性的添加新的逻辑存储组，从容实现存储容量的线性扩容。**

​    文件下载上，除了支持通过API方式，目前还提供了apache和nginx的插件支持，同时也可以不使用对应的插件，直接以Web静态资源方式对外提供下载。目前FastDFS(V4.x)代码量大概6w多行，内部的网络模型使用比较成熟的libevent三方库，具备高并发的处理能力

#### **优点**

**1）系统无需支持POSIX(可移植操作系统)，降低了系统的复杂度，处理效率更高**
**2）支持在线扩容机制，增强系统的可扩展性**
**3）实现了软RAID，增强系统的并发处理能力及数据容错恢复能力**
4）支持主从文件，支持自定义扩展名
**5）主备Tracker服务，增强系统的可用性**

**缺点**

**1）不支持断点续传，对大文件将是噩梦(FastDFS不适合大文件存储)**

* (2019.12.30 V6.06版本已支持断点续传)

**2）不支持POSIX通用接口访问，通用性较低**
**3）对跨公网的文件同步，存在较大延迟，需要应用做相应的容错策略**
**4）同步机制不支持文件正确性校验，降低了系统的可用性**
5）通过API下载，存在单点的性能瓶颈



FastDFS-Github：https://github.com/happyfish100/fastdfs

FastDFS源码阅读解析：https://www.jianshu.com/p/406bd1dc8f96

FastDFS讲解：https://zhuanlan.zhihu.com/p/61735659

https://www.jianshu.com/p/b7c330a87855



链接：https://www.zhihu.com/question/26993542/answer/417405770
来源：知乎



* FastDFS是一个开源的轻量级分布式文件系统，它对文件进行管理，功能包括：文件存储、文件同步、文件访问（文件上传、文件下载）等，解决了大容量存储和负载均衡的问题。特别适合以文件为载体的在线服务，如相册网站、视频网站等等。
* 三个角色：跟踪服务器（tracker server）、存储服务器（storage server）和客户端（client）
  * **tracker server**：跟踪服务器，主要做调度工作，起负载均衡的作用。在内存中记录集群中所有存储组和存储服务器的状态信息，是客户端和数据服务器交互的枢纽。相比GFS中的master更为精简，不记录文件索引信息，占用的内存量很少。
    * FastDFS的协调者，负责管理所有的storage server和group，每个storage在启动后会连接Tracker，告知自己所属的group等信息，并保持周期性的心跳，tracker根据storage的心跳信息，建立group==>[storage server list]的映射表。
    * 需要管理的元信息很少，会全部存储在内存中；另外tracker上的元信息都是由storage汇报的信息生成的，本身不需要持久化任何数据，这样使得tracker非常容易扩展，直接增加tracker机器即可扩展为tracker cluster来服务，cluster里每个tracker之间是完全对等的，所有的tracker都接受stroage的心跳信息，生成元数据信息来提供读写服务。
    * **storage server**：存储服务器（又称：存储节点或数据服务器），文件和文件属性（meta data）都保存到存储服务器上。Storage server直接利用OS的文件系统调用管理文件。
      * 以组（卷，group或volume）为单位组织，一个group内包含多台storage机器，数据互为备份，存储空间以group内容量最小的storage为准，所以建议group内的多个storage尽量配置相同，以免造成存储空间的浪费。
      * 以group为单位组织存储能方便的进行应用隔离、负载均衡、副本数定制（group内storage server数量即为该group的副本数），比如将不同应用数据存到不同的group就能隔离应用数据，同时还可根据应用的访问特性来将应用分配到不同的group来做负载均衡；缺点是group的容量受单机存储容量的限制，同时当group内有机器坏掉时，数据恢复只能依赖group内地其他机器，使得恢复时间会很长。
      * group内每个storage的存储依赖于本地文件系统，storage可配置多个数据存储目录，比如有10块磁盘，分别挂载在`/data/disk1-/data/disk10`，则可将这10个目录都配置为storage的数据存储目录。
      * storage接受到写文件请求时，会根据配置好的规则，选择其中一个存储目录来存储文件。为了避免单个目录下的文件数太多，在storage第一次启动时，会在每个数据存储目录里创建2级子目录，每级256个，总共65536个文件，新写的文件会以hash的方式被路由到其中某个子目录下，然后将文件数据直接作为一个本地文件存储到该目录中。
    * **client**：客户端，作为业务请求的发起方，通过专有接口，使用TCP/IP协议与跟踪器服务器或存储节点进行数据交互。FastDFS向使用者提供基本文件访问接口，比如upload、download、append、delete等，以客户端库的方式提供给用户使用。
* ![img](https://upload-images.jianshu.io/upload_images/3696220-9824c50495fa8e2a.png?imageMogr2/auto-orient/strip|imageView2/2/w/1198/format/webp)

***

##### Ceph

https://blog.csdn.net/mingongge/article/details/100788388

Ceph是一套高性能，易扩展的，无单点的分布式文件存储系统，提供对象存储，块存储，文件存储服务。目前应用广泛。

主要节点有Monitor、OSD、MDS等类型。MON管理维护集群，OSD时间存储数据，MDS为元数据服务器，不直接给client提供数据服务。Ceph采用CRUSH算法确定对象存储位置。OSD之间，OSD与Mon之间采用心跳机制判断是否有OSD节点失效。

https://www.zhihu.com/question/21718731/answer/21545274

CRUSH算法：Controlled, Scalable, Decentralized Placement of Replicated Data，数据分布均衡，并行度高。

CRUSH算法的目的是，为给定的PG(即分区)分配一组存储数据的OSD节点。

首先计算数据*x*的Hash值并将结果和PG数目取余，以得到数据*x*对应的*PG*编号。然后，通过CRUSH算法将PG映射到一组OSD中。最后把数据*x*存放到PG对应的OSD中。这个过程中包含了两次映射。PG是抽象的存储节点，它不会随着物理节点的加入或则离开而增加或减少，因此数据x到PG的映射是稳定的。

https://blog.csdn.net/nirendao/article/details/85240430

https://www.cnblogs.com/shanno/p/3958298.html

ceph

* 一种为优秀的性能、可靠性和可扩展性而设计的统一的分布式文件系统。最早起源于Sage就读博士期间的工作（最早的成果于2004年发表），并随后贡献给开源社区。在经过了数年的发展之后，目前已得到众多云计算厂商的支持并被广泛应用。RedHat及OpenStack都可与Ceph整合以支持虚拟机镜像的后端存储。
* 特点：
  1. 高性能
     * 摒弃了传统的集中式存储元数据寻址的方案，采用CRUSH算法，数据分布均衡，并行度高
     * 考虑了容灾域的隔离，能够实现各类负载的副本放置规则，例如跨机房、机架感知等
     * 能够支持上千个存储节点的规模，支持TB到PB级的数据
  2. 高可用性
     * 副本数可以灵活控制
     * 支持故障域分隔，数据强一致性
     * 多种故障场景自动进行修复自愈
     * 没有单点故障，自动管理
  3. 高可扩展性
     * 去中心化
     * 扩展灵活
     * 随着节点增加而线性增长
  4. 特性丰富
     * 支持三种存储接口：块存储、文件存储、对象存储
     * 支持自定义接口，支持多种语言驱动
* 架构
  * 支持三种接口
    * Object：有原生的API，而且也兼容Swift和S3的API
    * Block：支持精简配置、快照、克隆
    * File：Posix接口，支持快照
  * ![640?wx_fmt=png](https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/icNyEYk3VqGk91oZGzW0jMNv73lKibM81QhjcewG8mWGufpxnich313icS4HGmxNIzYyuIprM5TxmXkO7xjoRbyvog/640?wx_fmt=png)

***

##### GFS

https://blog.csdn.net/u011436427/article/details/98198935

https://www.cnblogs.com/xybaby/p/8967424.html

GFS是google分布式文件存储，是为了存储海量搜索数据而设计的专用文件系统。

采用单一主控机+多台工作机的模式，由一台主控机(Master)存储系统全部元数据，并实现数据的分布、复制、备份决策，主控机还实现了元数据的checkpoint和操作日志记录及回放功能。

适用于存储大量大型文件；有完善的故障处理、文件备份机制，对于大量客户端并发的追加写有大量的优化，以保证写入的高效性与一致性；更看重持续稳定的带宽而不是单次读写的延迟。

GFS系统由三部分组成：GFS master、GFS Client、GFS chunkserver。其中，GFS master只有一个，而chunkserver和client可能有多个。

数据的冗余是以Chunk为基本单位的，而不是文件或者机器。数据流与控制流是分开的。副本冗余的一致性保证“relaxed consistency”：relaxed是指，系统在某些情况下是不保证一致性，比如读取到尚未完全写完的数据；比如重复的append数据（读取数据的应用自行保证幂等性）。在这些异常情况下，一致性问题需要应用程序来处理。

https://blog.51cto.com/4964151/2420902

#### 探索了FastDFS的基本功能

* 上传机制：首先客户端请求Tracker服务获取到存储服务器的ip地址和端口，然后客户端根据返回的IP地址和端口号请求上传文件，存储服务器接收到请求后生产文件，并且将文件内容写入磁盘并返回给客户端file_id、路径信息、文件名等信息，客户端保存相关信息上传完毕。

  1. **选择tracker server**

   * 客户端在upload文件时可以任意选择一个trakcer
     * 选择存储的group 当tracker接收到upload file的请求时，会为该文件分配一个可以存储该文件的group

  2. **选择storage server**
     * 当选定group后，tracker会在group内选择一个storage server给客户端
  3. **选择storage path**
     * 当分配好storage server后，客户端将向storage发送写文件请求，storage将会为文件分配一个数据存储目录
  4. **生成Fileid**
  5. 生成文件名

  * 下载机制：客户端带上文件名信息请求Tracker服务获取到存储服务器的ip地址和端口，然后客户端根据返回的IP地址和端口号请求下载文件，存储服务器接收到请求后返回文件给客户端。

* 同步时间管理：

  * 每个存储服务器都需要定时将自身的信息上报给tracker，这些信息就包括了本地同步时间（即，同步到的最新文件的时间戳）。而tracker根据各个存储服务器的上报情况，就能够知道刚刚上传的文件，在该存储组中是否已完成了同步
  * 写文件时，客户端将文件写至group内一个storage server即认为写文件成功，storage server写完文件后，会由后台线程将文件同步至同group内其他的storage server。
  * 每个storage写文件后，同时会写一份binlog，binlog里不包含文件数据，只包含文件名等元信息，这份binlog用于后台同步，storage会记录向group内其他storage同步的进度，以便重启后能接上次的进度继续同步；进度以时间戳的方式进行记录，所以最好能保证集群内所有server的时钟保持同步。
  * storage的同步进度会作为元数据的一部分汇报到tracker上，tracke在选择读storage的时候会以同步进度作为参考。 比如一个group内有A、B、C三个storage server，A向C同步到进度为T1 (T1以前写的文件都已经同步到B上了），B向C同步到时间戳为T2（T2 > T1)，tracker接收到这些同步进度信息时，就会进行整理，将最小的那个做为C的同步时间戳，本例中T1即为C的同步时间戳为T1（即所有T1以前写的数据都已经同步到C上了）；同理，根据上述规则，tracker会为A、B生成一个同步时间戳。
  * 精巧的文件ID——FID
    * 文件索引信息包括：组名，虚拟磁盘路径，数据两级目录，文件名
    * 组名：文件上传后所在的存储组名称，在文件上传成功后有存储服务器返回，需要客户端自行保存。
    * 虚拟磁盘路径：存储服务器配置的虚拟路径，与磁盘选项store_path*对应。
    * 数据两级目录：存储服务器在每个虚拟磁盘路径下创建的两级目录，用于存储数据文件。
    * 文件名：与文件上传时不同。是由存储服务器根据特定信息生成，文件名包含：源存储服务器IP地址、文件创建时间戳、文件大小、随机数和文件拓展名等信息。
  * **快速定位文件**
    * 1、通过组名tracker能够很快的定位到客户端需要访问的存储服务器组，并将选择合适的存储服务器提供客户端访问；
    * 2、存储服务器根据“文件存储虚拟磁盘路径”和“数据文件两级目录”可以很快定位到文件所在目录，并根据文件名找到客户端需要访问的文件。

* 不同分布式文件系统的对比

  ![](D:\科大\大二下\操作系统\调研报告\分布式+WebAssembly调研-pqz\图片\5.png)

* 了解Ceph架构

  * ![img](https://images2015.cnblogs.com/blog/1014002/201610/1014002-20161028131547062-1946030091.png)

    缓存层(A cache tier)为Ceph客户端提供更好的I/O性能，而数据存储在存储层(a backing storage tier)。

    用相对快速/昂贵的设备(比如SSD)创建pool作为缓存层(A cache tier)，用纠删码池或者相对慢速/便宜的设备创建pool作为经济的存储池。

    Ceph(The Ceph objecter)负责对象存放的位置，分层代理(the tiering agent)确定什么时候把数据对象从缓存层(the cache)存储到存储层(the backing storage tier)。因此对Ceph客户端而言缓存层(the cache tier)和存储层(the backing storage tier)是完全透明的。

  * 分层代理：分层存储数据迁移方案，缓存分层代理负责在缓存层与存储层间的数据的自动迁移，然而管理员有权利配置数据如何迁移 

  * 两种数据迁移模式

    * 回写模式  ：如果管理员配置缓存层为回写模式,CEPH客户端把数据写入缓存层，并且收到缓存层的ACK（确认字符），写入缓存层的数据随后迁移到存储层，然后从缓存层清除，读取的话如果客户端要读取的数据在存储层，代理会把数据先迁移到缓存层，后再发往客户端，客户端与缓存层进行I/O ，大概流程如下所示

      ![img](https://images2015.cnblogs.com/blog/1014002/201610/1014002-20161028132635906-1353507942.png)

    * 只读模式：客户端写数据到存储层，读数据的时候，ceph从存储层拷贝需要的数据到缓存层，根据定义好的规则，旧数据从缓存层删除 ,大概流程如下所示

      ![img](https://images2015.cnblogs.com/blog/1014002/201610/1014002-20161028133303484-1772629902.png)

    * 第一种回写模式主要用于经常变动的数据，第二种只读模式主要用于不经常变动的数据，因为数据是从缓存层读取的，因此数据可能是过时的数据，换一句话说数据是弱一致的，因为客户端写入的时候是不经过缓存层的，缓存层并不能保证数据是最新的 而第一种模式可以保证这一点

  * 分层存储的目的和缺点

    * 目的:更好的利用磁盘资源，可以将SSD作为缓冲层，HDD作为后端存储，这样热数据可以在SSD上被快读的读取，大量的冷数据在HDD上存储

  * 缺点：

    * 使用分层存储可能会引起性能的下降，因为数据要经常移出或读进缓冲，这会增加读取时间，缓冲 的有效应用场景应该是针对大文件，经常读而少写的数据。而且缓存需要足够大。
    * 添加缓存层容易引起机制复杂性
    * 进行性能测试时会显示出比较差的性能（确定真正的热数据需要昂贵的代价）