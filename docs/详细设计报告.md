# **基于 Rust 和 WebAssembly 的分布式文件系统**详细设计报告



雷雨轩	裴启智	刘逸菲	孙一鸣	曲阳



## 项目介绍

分布式文件系统可以有效解决信息爆炸时代存在的成指数倍增长的数据的存储和管理难题：将固定于某个地点的某个文件系统，扩展到任意多个地点/多个文件系统，众多的节点组成一个文件系统网络。每个节点可以分布在不同的地点，通过网络进行节点间的通信和数据传输。人们在使用分布式文件系统时，无需关心数据是存储在哪个节点上、或者是从哪个节点从获取的，只需要像使用本地文件系统一样管理和存储文件系统中的数据。

通过与老师沟通以及对于各个文件系统的考察后，我们发现当前业界对于分布式文件系统的追求无非就是几个方面：

* 搭建部署系统操作是否繁复

* 传输和储存文件是否安全可靠

* 文件系统性能是否满足使用要求

* 对计算机的性能要求是否高

* 对文件的格式是否有限制

而具体到不同的应用场景下，对于以上的要求则各有取舍。

结合对往届项目的实现的研究，我们计划并完全实现了这样一个家庭式分布式文件系统：

* 高效利用分散在不同设备上的存储空间，方便多人合作办公，避免资源浪费
* 所有安装了客户端的机器共享、贡献存储空间和存储文件碎片，并对数据做好高效的备份；一个专门用于协调处理请求，维持系统状态的服务端；
* 有浏览器的电脑都可访问分布式文件系统
* 在以上要求外，尽可能让性能相对好，安全性相对高，操作简单

在调研报告和可行性报告部分，我们已经对于我们实现思路做了分析。现在首先简要概括本项目的完成情况：

在17级项目的基础上，小组成员齐心协力，学习rust语言并完成了client、server端的完全改写，实现了整个分布式文件系统的逻辑架构。此外，采用前后端分离的模式，采用actix-web框架将web应用的后端用rust语言改写，并与17级项目的web前端衔接，最终呈现出完整的分布式文件系统，并在浏览器端提供了用户对文件系统的管理操作。

## 立项依据？

## 纠删码？

## 总体设计架构

### 系统结构

![](.\photo\25.png)

系统结构如上图。程序包括客户端程序、服务端程序、web 服务程序三部分。其中，客户端程序运行在客户主机（即存储端）上，服务端程序与web服务程序运行在服务端server上。通过网页浏览器访问该分布式文件系统，无需运行其他程序。

- 客户端

  - 文件夹监控线程（常开）

    对应 client 中的 FolderScanner 模块。该线程用于每隔一段时间扫描一次共享文件夹，查看共享文件夹中是否有新文件需要上传至服务器。

  - 控制连接线程（常开）

    对应 client 中的 SeverConnecter 模块。该线程用于每隔 5 秒向服务器发送一次报文，通过心跳连接的方式确保客户端与服务器的长期连接。同时，该线程还负责处理服务器发回至客户端的控制报文。

  - 数据连接线程

    该线程用于必要时与服务器交换数据。

- 服务器进程

  - 控制连接监听线程（常开）

    对应 sever 中的 ControlConnect 中的 SeverThread 模块。该线程用于监听服务器的控制端口，若有客户端发来请求/连接，其将创建一个控制连接线程处理该连接。

  - 控制连接线程

    对应 sever 中的 ControlConnect 中的 ClientThread 模块。每个控制连接线程对应一个客户端，该线程用于读取并处理客户端通过控制端口发来的报文。

  - 数据连接监听线程（常开）

    对应 sever 中的 DataConnect 中的 SeverThread 模块。该线程用于监听服务器的数据端口，若有客户端发来请求/连接，其将创建一个数据连接线程处理该连接。

  - 数据连接线程（不常开）

    对应 server 中的 DataConnect 中的 ClientThread 模块。该线程用于读取并处理客户端通过数据端口发来的报文。

- web 服务器

  考虑前后端分离的方式来完成整个web应用的设计，便于调试，同时便于各平台兼容。对后端而言，不提供任何和界面表现有关的内容，只需要接收前端的http请求并返回相应数据即可。为了统一数据格式，数据传输一律采用Json格式。

  ![](.\photo\34.png)

  - 后端

    * Actix web 是小型的、实用、快速 Rust web 框架。

    * 支持 Client/server WebSockets
  
    * 包含一个异步的 HTTP 客户端
  
    * 强大的请求定向
  
    * 使用稳定的 Rust 版本（如 Rocket 需要 nightly 版本的 Rust ）
  
    * Actix-web 框架是 Rust web 框架中性能最高的。它依靠 tokio 作为异步运行时，适于对性能有严格要求的，大流量 web 应用。
  
    * 性能测试图:
  
      ![](.\photo\32.png)
  
      ![](.\photo\33.png)
  
  - 前端
  
    前端主要借鉴了17级大作业的实现，为了与我们的Rust后端交互，对其中的文件进行了一定的删减和修改，并优化了界面，添加了下载的用时统计。
  
    采用的布局主要如下：
  
    * Tomcat Web应用服务器
    * Struts2 动态网站网站应用调度框架
    * BOOTSTRAP网页主题
    * JQery+AJAX异步C/S通讯+JSON+MySql

### 技术路线

- MySQL：通过 MySQL 数据库来记录储存信息，比如文件和碎片的位置和属性等，并通过数据库中的 Request 表单处理请求，达到在 server、client 和 web 端之间交互的功能。

* JQuery：一个 JavaScript 库，极大地简化了 JavaScript 编程，易于学习。
* AJAX：即Asynchronous JavaScript And XML，是指一种创建交互式、快速动态网页应用的网页开发技术，无需重新加载整个网页的情况下，能够更新部分网页的技术。
* JSON：一种轻量级的数据交换格式，基于 ECMAScript的一个子集，采用完全独立于编程语言的文本格式来存储和表示数据。简洁和清晰的层次结构使得 JSON 成为理想的数据交换语言。 易于人阅读和编写，同时也易于机器解析和生成，并有效地提升网络传输效率。
* Bootstrap：基于HTML、CSS、JavaScript 开发的简洁、直观、强悍的前端开发框架，使得 Web 开发更加快捷。Bootstrap提供了优雅的HTML和CSS规范，它即是由动态CSS语言Less写成。
* Struts2动态网站：一个基于MVC设计模式的Web应用框架，它本质上相当于一个servlet，在MVC设计模式中，Struts2作为控制器(Controller)来建立模型与视图的数据交互。
* Tomcat Web应用服务器：
  * 一个免费的开放源代码的Web 应用服务器，属于轻量级应用服务器，在中小型系统和并发访问用户不是很多的场合下被普遍使用，是开发和调试JSP 程序的首选。
  * 可利用它响应HTML页面的访问请求。
  * 实际上Tomcat是Apache 服务器的扩展，但运行时它是独立运行的，所以当你运行tomcat 时，它实际上作为一个与Apache 独立的进程单独运行的。

## 工作记录？



## 模块改写分析

### client

- client

  client和SynItem模块：

  * 主要功能是读取配置文件后对各个参数作一个初始化。然后会开启控制连接线程与server端相连，开启文件夹监控线程每隔一定间隔将会扫描文件夹看是否有新的文件要上传到文件系统。

  * 实现方面：与原来模块的一个区别是：原来java文件利用了synchronized关键字以及SynItem类来作为状态量以实现锁机制，最终实现线程间的同步（当子线程出现错误时，唤醒沉睡的主线程并结束所有子线程）

    但在rust中，本身没有类这个概念，锁机制的使用也有所不同，所以考虑直接创建带有条件变量的锁：

    `let status = Arc::new((Mutex::new(0), Condvar::new()));`

    把锁分别clone到folderScanner和ServerConnecter两个线程；然后主线程调用wait进入睡眠；由于该条件变量的存在，当子线程出错时，则子线程会互斥的修改该条件变量，再唤醒wait中的主线程，主线程检测到状态值改变，则会输出相应报错信息，最后终止所有client的线程。这样一来SynItem类就不再需要了

- com

  该模块使用 erasure code 算法对文件分块，具体采用 rust 的 crate reed-solomon-erasure（ "4.0"）进行碎片构建。其中，Encoder 模块负责初始文件的编码与分片，Decoder 模块负责根据碎片还原出初始文件。

  - Encoder 模块

    - 功能

      该模块用于读取文件内容，然后将其整理为二维vector，以便使用 crate 中提供的 encode 方法进行编码，最后将结果写入文件碎片中。

      参数说明：inputFile_Path为要被分块的文件的路径；shardsFolder为存放文件碎片的文件夹位置，fid为文件的ID。

    - 实现时遇到的问题

      - 二维数组

        rust 教程中未提到二维数组的概念，因此使用 `Vec<Vec<u8>>` 实现二维 vector

        ```rust
        let mut shards:Vec<Vec<u8>> = vec![vec![0;shardSize.try_into().unwrap()];totalShards.try_into().unwrap()];
        ```

        此外，rust 要求 vector的索引为 usize 类型，因此多处使用 as 进行类型转换。

        注：shards 中的前四个字节为文件大小 fileSize

  - Decoder 模块

    - 功能

      该模块用于读取多个文件碎片内容，然后根据碎片文件名的编号将其整理为二维vector，以便使用 crate 中提供的 reconstruct 方法重建所有碎片，最后利用数据碎片还原初始文件。

      参数说明：shardsFolder为碎片所在的文件夹路径；decodedFile为要复原的文件路径；fid为文件ID；noa为文件碎片的数量。

- connect

  - 功能：与服务器通讯并进行文件传输。
    - FileTransporter 文件传送模块，负责与 Server 间使用 TCP 协议发送和接收文件。

    - FragmentManager 

      - 数据连接模块，维护客户端上的文件碎片，负责处理数据链接中的客户机碎片上传报文、客户机碎片下载报文与客户机碎片删除报文。
      - 调动FileTransporter中的函数进行文件碎片的传输

    - ServerConnect 控制连接模块，根据心跳连接机制维护客户端和服务端连接。

      客户端每 5s 发送报文 “1 x y” ，1 是标志，x 是客户端ID，y 是客户端剩余存储空间。客户端每发送一次标志为 1 的报文，服务端会在数据库中根据客户端 ID 查询客户端未读请求，返回请求数给客户端，客户端会收到报文 “received with x unread request” 。

    Java java.net.Socket 库对心跳连接有很好的支持，只要设置 setKeepAlive(true) 以及心跳连接时间即可实现。 Rust std::net::TcpStream 没有这样的支持，因此心跳连接的实现更加底层。

  - 实现时遇到的问题

    考虑到 Java 是面向对象语言，FileTransporter 模块原代码中定义了一个没有字段只有方法的抽象类；而 Rust 并非面向对象语言，因此不再定义 FileTransporter 类，直接定义 send_file, recv_file 两个函数。另外，由于 Rust 没有 DataInputStream, DataOutputStream 类，我们在考察 FileTransporter 模块作用后将函数参数类型更改为 TcpStream ，并删去了多余的参数。

- fileDetector

  - FileAttrs

    - 功能

      定义文件属性信息结构体模块，其中有 name，path，attr 和 noa 信息。

  - FileUploader

    - 功能

      createConnection 负责使用 serverIP 和端口号创建与 server 端的 TcpStream 连接；checkFolders 负责向 server 端发送需要监察的文件夹，以报文 “6 0 ”开头，而后发送所有文件夹路径；registerFile 负责将文件信息发送给 server 用来后续在数据库中进行记录，报文为 “4 0 {name} {path} {attr} {noa} false”；pushFragment 负责调用 send_file 函数发送碎片，报文格式为“5 {fileId} {fragmentNum} {fragmentCount}”。

    - 实现时遇到的问题

      - Java 中使用了 DataInputStream 和 DataOutputStream 来收发信息，而在 Rust 中没有类似类，直接使用了 TcpStream 进行直接连接。
    - 使用 PathBuf 替代 java 中的 Path 和 File 类。
  
- FileUtil
  
  - 功能
  
    工具方法模块。提供清空文件夹 clearFolder 方法和文件夹遍历getAllFiles 方法。
  
  - FolderScanner
  
    - 功能
  
      在客户端启动模块（client）中，客户端创建文件夹监控线程执行 FolderScanner 的 run 方法。执行时，先调用 FileUploader 模块中的 checkfolder 方法与服务器连接，并向服务器发送新建文件夹报文（报文标志为6），以确保被监控的各文件夹在分布式文件系统中的对应逻辑位置存在。之后，每隔 interval_mills （设置为1分钟）时间，检查客户端的共享文件夹中是否有新文件。若有，则通过 handleFile 方法获取文件的属性，并调用 FileUploader 模块中的 registerfile 方法向服务器注册这个文件。若注册成功，则调用 文件分块模块的 Encoder 模块将文件分块，然后调用 FileUploader 模块中的 pushFragment 方法向服务器上传各文件碎片。处理文件夹中的所有文件后，调用 FileUtil 的 clearfolder 方法清空文件夹。
  
    - 实现时遇到的问题
  
      - static 关键字
  
        由于 rust 不能像 java 一样使用 static 关键字声明类变量，因此选择先在 init 方法中，将“类变量”的值赋给可变全局变量（用static mut 声明）；再在每次使用 new 方法获得结构体时，利用全局变量给结构体中的字段赋值。 
  
        ```rust
        pub fn init(tmp:&String){
           unsafe{
                 //static_tmp为可变全局变量
               static_tmp = (*tmp).clone().to_string();
             }
      }
        
        ```
      
      pub fn new(f:Vec<PathBuf>,addr:Vec<String>,) -> FolderScanner {
                 FolderScanner{
        			//---snip---
                    tmpFragmentFolder:unsafe{ PathBuf::from(static_tmp.clone()) }
            }
    }
        ```
  
      - File 类
  
        由于 rust 中的 File 结构体不能像 Java 中的 File 类一样既可指文件，又可指文件夹，因此使用 ` std::path::PathBuf` 结构体代替原 Java 程序中的 File 类。并且经过比较，` std::path::PathBuf` 结构体是比 ` std::path::Path` 结构体更加合适的。
  
      - 文件属性获取
      
        由于 rust 中的 `fs::metadata.permissions` 结构目前只实现了 readonly() （获取其是否为只读权限的）方法，因此无法获取文件的写属性。
        ```

### server

- controlConnect

  - 功能：控制连接，与客户端进行通讯。
    - 常开一个 controlConnect ServerThread 线程，监听控制连接端口。对于接收到的每个客户机的连接和请求，创建一个新的 ClientThread 线程处理。
    - 创建的 ClientThread 新线程中，接收从 client 发回的报文并完成相应的任务。ClientThread 可以修改 device 的信息，或查询需要的数据库 request 并发回客户端。

  - 实现时遇到的问题

    同样由于 Rust 没有 DataInputStream, DataOutputStream 类，将结构体中这两个类型对应的字段合并为一个 TcpStream 类型的字段；使用时，调用 TcpStream clone 方法得到两个变量，分别用于接收和发送数据。

- database

  - 功能：

    DeviceItem、FileItem 和 RequestItem 定义了数据库所需结构体，并且也配备了相应的获取值和改变值的方法。

    Query 中 new 方法连接到了 pool 连接池，从中进行查询。而后使用 MySQL 的 statement 语句对信息进行增删改查。查询信息处，查询失败返回 id 值为-1，查询成功但库中没有对应信息返回 id 值为0，查询成功并且库中有对应信息返回相应信息。若有可能查询到多个相应信息，则返回对应信息的向量。增加、删除、修改也使用对应 statement 进行操作。

  - 实现时遇到的问题

    - rust 不支持函数重载，改写时有些函数修改了名字，在后面加上 _Byid 等
    - 学习了很多有关数据库的知识。
    - 查询数量时，首先把符合要求的信息都储存到一个向量中，而后计算向量的长度，即为所需数量。

- dataConnect

  - 功能：数据连接，与客户端进行文件传输。
  - 常开一个 dataConnect ServerThread 线程，监听数据连接端口。对于每个客户机的连接和请求，创建一个新的 ClientThread 线程处理。
    - ClientThread 接收从客户端发回的报文，根据报文调用相应的函数处理。可以进行发送、接收、查询、删除、记录碎片等操作。

### web

- com

- database

- userManagement

  * FileDownloader

    实现功能包括：主要是为下载的一系列操作写的响应，包括：向数据库登记文件碎片下载请求；获取当前文件下载进度；对下载得到的文件碎片解码得到原文件，并删除对应本地文件碎片。

    * downloadRegister(path1:String, name1:String) -> String

      按函数名直译理解为“下载登记”。传入参数应为待下载文件的虚拟地址和名字。
  
      查询在线的客户端数量，若无在线客户端，直接返回 "NotEnoughFragments" 。若文件碎片总数小于 1 ，直接返回 "Error" 。
  
      针对各个文件碎片编号（同时也是碎片文件名，计算方法：file_item.id（即请求文件的id） * 100 + i, i in 0..noa, noa 为文件碎片数），用文件碎片编号去 queryFragment，然后判断query的结果（结果即返回该碎片所在的客户端id）和device id是否相等，若有在线设备的 id 和此编号相等，则将对应请求加入 RequestItems 数组。
  
      上述循环完成后，若 RequestItem 数组长度大于 noa / 2 （最少需要一半数量的碎片可以还原出文件），则针对 RequestItems 数组中的每一个元素调用 query.addRequest 方法插入数据库查询请求，并返回 "OK" ；否则直接返回 "NotEnoughFragments" 。
  
    * progressCheck(path1:String, name1:String) -> String
  
      获取当前文件下载进度。参数同上。
  
      如果待下载文件 id 为 -1 ，直接返回 "Error"。
  
      对 fragmentFolderPath ("D:webapps/DFS/CloudDriveServer/downloadFragment/") 中所有文件遍历查看，若文件名去掉后两位后与待下载文件 id 相同，则它是待下载文件的碎片，collected_file 变量加一。
  
      完成这个遍历后，计算文件下载进度百分比 percentage 为 2 * collected_file / file_item.noa （只需要一半的文件碎片），返回 (percentage * 100) as i32 转化的字符串。
  
    * decodeFile(path1:String, name1:String) -> String
  
      从下载到的碎片文件（放在fragmentFolderPath路径下）中解码，得到待下载的原文件（放在fileFolderPath路径下）。
  
      若调用 Decoder::decode 函数返回 false ，则直接返回 "Error" 。调用decode函数成功后，遍历 fragmentFolderPath 中所有文件，查找对应文件的碎片并删除，遍历结束后返回 "OK" 。
  
  * GetFileList
  
    向数据库查询当前路径下的文件和目录列表，对虚拟文件系统中点击一个文件夹时的操作作响应，调用此模块来查询数据库里该文件夹下的子目录，并动态生成字符串形式的html语言返回到前端，为前端网页显示做准备。
    
  * UserReg/UserLogin: 这两个模块为用户注册与登录模块，主要对从前端传过来的用户名和密码做操作，分别为 
  
    * 注册：插入用户信息到数据库
    * 登录：根据用户名查询数据库，并判断密码是否与数据库中记录是否匹配
  
  * main：利用actix-web框架的语法，开启端口http://localhost:8080进行监听，并匹配前端发出的每个http请求的url，以对不同的前端操作做出不同的响应
  
    * 用户注册：post("/UserReg")
  
      接受http请求的数据为用户名和用户密码；
  
      接收到后调用函数UserReg::execute(params.userName,params.userPasswd);来向数据库user表中插入一条用户信息，建立新用户；
  
      返回到前端的响应为Json格式化的字符串
  
    * 用户登录：\#[post("/UserLogin")]
  
      接受http请求的数据为用户名和用户密码；
  
      接收到后调用函数UserLogin::execute(params.userName,params.userPasswd);来向数据库user表中查询用户信息，匹配成功则用户可以成功登录
  
      返回到前端的响应为Json格式化的字符串
  
    * 文件目录刷新交互：\#[post("/GetFileList")]
  
      接受http请求的数据为文件在虚拟文件系统中的逻辑路径
  
      接收到后调用函数GetFileList::execute(params.QueryPath) ，来从数据库中查询该文件夹下的文件内容，并生成html格式的字符串，以Json格式返回到前端
  
    * 文件下载请求：\#[post("/DownloadReg")]
  
      接受http请求的数据为文件在虚拟文件系统中的逻辑路径和名称
  
      接收到后调用函数FileDownloader::downloadRegister(params.path,params.name);
  
      来从数据库中插入下载请求。
  
    * 文件下载进度请求：\#[post("/progressCheck")]
  
      接受http请求的数据为文件在虚拟文件系统中的逻辑路径和名称
  
      接收到后调用函数FileDownloader::progressCheck(params.path.clone(),params.name.clone());
  
      来检查web端存放碎片的文件夹中碎片数目。
  
    * 文件碎片解码请求:\#[post("/decodeFile")]
  
      接受http请求的数据为文件在虚拟文件系统中的逻辑路径和名称
  
      接收到后调用函数FileDownloader::decodeFile(params.path.clone(),params.name.clone());
  
      来利用纠删码模块对碎片进行解码，还原为文件，并删除所有碎片

## 系统性能分析

### Rust本身的优势**（从之前的报告中筛选）**

### 低资源占用

* 大多数运行条件下，一个Rust 程序比 Java 消耗的内存会少上一到两个数量级，如下图。而且原17级项目在结束客户端服务端之后还会有一些进程未被自动关闭，这也是一个小的缺陷。
* ![](.\photo\22.png)

### 上传速度分析

* 上传速度取决于在线客户端的数量和客户端与服务器数据传输速度。当多个客户机在线
  时，客户机可以同时与服务器进行传输，从而摆脱用户网络上传速度的限制。

* 实际测试时只测试了一个客户端开启，并使用本地端口上传一系列不同大小的文件，结果仅供参考如下图

  ![](.\photo\23.png)

* 可以看到，在文件大小达到一定阈值后，速度整体大约在5-6MB/s

### 下载速度分析

* 下载速度取决于所用网络与服务器之间连接速度。并且由于通过网络下载时需要先收集碎
  片，碎片上传到服务器的速度也会影响到实际下载速度。

* 在单客户端并使用本地端口进行连接的情况下，测得下载图（并与Java对比）如下

  ![](.\photo\24.png)

* 可以看到二者的速度大致相同

* 根据我们的预期，如果将前端采用Rust实现并打包为WebAssembly部署到浏览器上，那么本项目下载所需的时间会进一步下降

## 整体运行方式与使用说明

一鸣的部署文档部分

***

### Tomcat服务器的部署（以IDEA为例）

## 未来展望

~~（我现在的想法是把不足合并到未来展望之下，“前端设想”作为前端这一块的详细说明）~~

### 前端设想

* Rust 前端架构选择：

  * Yew

    Yew 是受 Elm 和 React 启发的 Rust 前端框架，主要目的是使用 WebAssembly 来创建多线程的前端 web 应用。它与 JavaScript 有良好的互操作性。

  * Seed

    Seed 是采用类似 elm 结构的 Rust 前端框架，同样在网页前端结合应用 Rust 和 WebAssembly 。它极少地需要额外费用、配置和样板文件。

  * Ruukh

    一个实验性的 Rust web 前端框架，用于完全使用 Rust 编写 web 应用。

    Ruukh 目前处于开发和试验中，非常不稳定。

  考虑到我们 Rust 全栈开发的目标和对项目稳定性的需求，我们决定选择 Seed 。

* Seed 简介

  Seed 采用 Elm 结构，它的核心包括以下三部分：

  * Model：应用的当前状态
  * View：把状态转化为网页端可视的 HTML
  * Update：根据网页端返回的 Msg 更新状态

  也因此 Seed 不需要额外的网页状态维护。另外，Seed 采用稳定版本的 Rust，不含有 unsafe 模块，保障应用的安全性。

* 前端模型设想

  参考 seed-realworld 示例和 17 级项目网页，将项目分为注册、登录、用户使用页面三个主要页面，分别设计各自的 Model 和 Msg 模型。

  初步设想的网页模型：

  * 注册和登录页面

    Model 结构体：用户当前状态，注册和登录需要输入的信息栏（用户名、密码、邮箱等），网页错误

    Msg 枚举体：页面跳转、注册或登录提交、注册或登录完成、网页错误

  * 用户使用页面

    Model 结构体：用户当前状态，文件显示状态，网页错误，下载目标路径填写栏

    Msg 枚举体：页面跳转、下载请求、下载完毕、上传请求、上传完毕、文件目录刷新请求、文件目录刷新完毕、改写目标路径提交、改写目标路径完毕

* 可能的挑战

  Seed 总体使用方面：

  * Seed 仍处于快速发展中，一些内容可能不稳定；比起更成熟的网页框架，可复用的代码少。

  * 可参考的文档较少，遇到的一些错误可能没有参考的解决方案

  本项目方面：

  * 动态刷新文件目录的处理
  * 上传下载 button 与后端的交互

### 不足

~~(不足和未来展望部分可以看情况删去一些，比如我们之后没有对数据库表项加关联的计划，就可以把这部分内容删掉)~~

* 前端的功能还不完整，目前每个用户都只能共享同一个虚拟文件系统。
* 架构方面，服务器作为 web 端与存储端的转发节点，导致运行效率瓶颈；文件在存储端编解码，没有应用到 WebAssembly 的优势。
* 数据库存储结构不够合理，表项之间的关联没有很好地设置。
* 能够存储的单个文件大小有限制，目前不能存储 50MB 以上的文件。 
* 运行时的配置比较复杂。

### 未来展望

* 大创中的目标：

  完善项目的功能和架构。

  * 实现 Seed 框架的前端，对浏览器页面加载交互，并利用 Rust 的 web-pack 等包将代码编译为 WebAssembly ，运行在浏览器中。

    完善前端功能，实现用户私有的虚拟文件系统。

  * 改进实现 web 端编解码文件，并在此应用 WebAssembly 计算效率优势。

  * 改善数据库设置。

  * 对更大的文件进行测试，

* 更进一步的目标：

  * 实现完整实用的基于 Rust 和 WebAssembly 的分布式文件系统，并将项目部署到公网上、投入使用。
  * 为 Rust 和 WebAssembly 开源社区做贡献。

#### 补充考虑？

* 在web应用(浏览器端展示)方面，后期调研发现WebAssembly编译Rust对于多线程以及文件IO等操作尚未提供支持，可能只能限制在web应用范围内的编译，又考虑到17级已经用Tomcat实现了一个相对轻量的web应用，所以小组决定让改写的代码与原项目的web应用作衔接，并在此基础上将采用前后端分离的方式，逐步将web应用替换为rust语言实现。

  而由于人力与时间限制，以及我们从0开始学习的成本，调研时遇到的坑与挑战，所以短短一学期内实现整个项目变得不太现实。所以我们最终更进一步，把后端用rust实现，并与原本web应用的前端做出了成功交互，完成了我们的大作业项目设计。

#### WebAssembly

把密集型大型计算工作交由WebAssembly解决

把Rust语言和前端都打包为wasm，多进行一次性的密集计算而非简单将特定几个函数编译为WebAssembly，可以有效提高对WebAssembly高计算性能的利用效率

## 参考文献

[Yew 中文文档](https://yew.rs/docs/v/zh_cn/)

[Ruukh 仓库](https://github.com/pepsighan/ruukh)

[about Seed](https://seed-rs.org/)

